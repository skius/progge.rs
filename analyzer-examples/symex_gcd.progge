fn analyze(x: int, y: int, n: int) {
    assume!(n > 15);
    if x >= 0 && y > 0 {
        let gcd = gcd(x, y);
        let gcd_rec = gcd_rec(x, y);

        if gcd > n {
            testcase!;
        }
        if gcd_rec > n {
            testcase!;
        }

        if gcd == gcd_rec {
            // This is not unreachable. Although abstract interpretation's over-approximation is correct
            // in this case, only symbolic execution can deliver a proof in form of a concrete
            // set of input values that reach this statement.
            unreachable!;
        }

        if gcd != gcd_rec {
            // While this is truly unreachable, neither abstract interpretation nor symbolic execution
            // can deliver a proof for this.
            unreachable!;
        }
        return;
    }

    return;
}

// Both a recursive GCD definition ...
fn gcd_rec(a: int, b: int) -> int {
    if b == 0 {
        return a;
    }
    return gcd_rec(b, a % b);
}

// ... and an iterative definition work.
fn gcd(a: int, b: int) -> int {
    let temp = 0;
    while b != 0 {
        temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}